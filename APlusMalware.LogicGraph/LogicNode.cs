// <copyright file="LogicNode.cs" company="aplusmalware.com">
//
// Copyright (c) 2016 A+ Malware
// All rights reserved. 
//
// MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this
// software and associated documentation files (the "Software"), to deal in the Software 
// without restriction, including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
// to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
// PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
// </copyright>
// <author>A+ Malware</author>

namespace APlusMalware.LogicGraph
{
    using System;
    using System.Collections.Generic;

    /// <summary>
    /// A node that can perform transformations on input and output to other logic nodes.
    /// </summary>
    /// <typeparam name="T">The type of the value of input and output.</typeparam>
    public abstract class LogicNode<T>
    {
        /// <summary>
        /// Nodes that this node outputs to.
        /// </summary>
        private readonly List<LogicNode<T>> _outNodes;

        /// <summary>
        /// Endpoints to edges between this node and inputs.
        /// </summary>
        private readonly EdgeEndpoint<T>[] _inEdgeEndpoints;

        /// <summary>
        /// Endpoints to edges between this node and outputs.
        /// </summary>
        private readonly EdgeEndpoint<T>[] _outEdgeEndpoints;

        /// <summary>
        /// Initializes a new instance of the LogicNode class.
        /// </summary>
        protected LogicNode()
        {
            _outNodes = new List<LogicNode<T>>(MaxOutputCount);
            _outEdgeEndpoints = new EdgeEndpoint<T>[MaxOutputCount];

            for (Int32 i = 0; i < MaxOutputCount; i++)
            {
                _outNodes.Add(null);
                _outEdgeEndpoints[i] = new EdgeEndpoint<T>();
            }
            OutNodes = _outNodes.AsReadOnly();

            Inputs = new List<LogicInput<T>>(MaxInputCount);
            _inEdgeEndpoints = new EdgeEndpoint<T>[MaxInputCount];
            for (Int32 i = 0; i < MaxInputCount; i++)
            {
                Inputs.Add(new LogicInput<T>());
                _inEdgeEndpoints[i] = new EdgeEndpoint<T>();
            }
        }

        /// <summary>
        /// Gets the step number of the last update.
        /// </summary>
        public Int32 LastStep { get; private set; } = -1;

        /// <summary>
        /// Gets the values of the inputs.
        /// </summary>
        public abstract T[] InputValues { get; }

        /// <summary>
        /// Gets the values of the outputs.
        /// </summary>
        public abstract T[] OutputValues { get; }

        /// <summary>
        /// Gets the maximum number of outputs supported.
        /// </summary>
        public abstract Int32 MaxOutputCount { get; }

        /// <summary>
        /// Gets the maximum number of inputs supported.
        /// </summary>
        public abstract Int32 MaxInputCount { get; }

        /// <summary>
        /// Gets the number of registered inputs.
        /// </summary>
        public Int32 ActiveInputCount { get; private set; }

        /// <summary>
        /// Gets the number of inputs that have been set.
        /// </summary>
        public Int32 SettedInputCount { get; private set; }

        /// <summary>
        /// Gets a value indicating whether or not all active inputs have been set.
        /// </summary>
        public Boolean AreAllSet { get { return ActiveInputCount == SettedInputCount; } }

        /// <summary>
        /// Gets a value indicating whether or not at least 1 active input has been set.
        /// </summary>
        public Boolean AreSomeSet { get { return ActiveInputCount != 0; } }

        /// <summary>
        /// Gets a list of nodes that this node outputs to.
        /// </summary>
        public IList<LogicNode<T>> OutNodes { get; }
        
        /// <summary>
        /// Gets a list of inputs.
        /// </summary>
        protected List<LogicInput<T>> Inputs { get; }

        /// <summary>
        /// Updates this node and the inputs of connected output nodes accordingly.
        /// </summary>
        /// <param name="stepNumber">The step number.</param>
        public void Update(Int32 stepNumber)
        {
            LastStep = stepNumber;
            InternalUpdate();
            ResetInputs();
        }

        /// <summary>
        /// Connects this node to an output node (head).
        /// </summary>
        /// <param name="outIndex">The output index of this node to use.</param>
        /// <param name="headNode">The output node to connect to.</param>
        /// <param name="headNodeInputIndex">The input index of the output node to connect to.</param>
        public void ConnectToHead(Int32 outIndex, LogicNode<T> headNode, Int32 headNodeInputIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (headNode == null)
                throw new ArgumentNullException(nameof(headNode));
            if (headNodeInputIndex >= headNode.MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (headNodeInputIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (_outEdgeEndpoints[outIndex].Active)
                throw new OutputEdgeAlreadyActiveException("Output is already active.", outIndex);
            if (headNode._inEdgeEndpoints[headNodeInputIndex].Active)
                throw new InputEdgeAlreadyActiveException("EdgeEndpoint node input is already active.", headNodeInputIndex);
            
            headNode.RegisterTail(headNodeInputIndex, this, outIndex);
            RegisterHead(outIndex, headNode, headNodeInputIndex);
        }

        /// <summary>
        /// Disconnects all inputs outputs.
        /// </summary>
        public void DisconnectAll()
        {
            for (Int32 i = 0; i < _outEdgeEndpoints.Length; i++)
            {
                DisconnectFromHead(i);
            }

            for (Int32 i = 0; i < _inEdgeEndpoints.Length; i++)
            {
                DisconnectFromTail(i);
            }
        }

        /// <summary>
        /// Disconnects from a head.
        /// </summary>
        /// <param name="outIndex">This node's output index that is connected to the head.</param>
        public void DisconnectFromHead(Int32 outIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (!_outEdgeEndpoints[outIndex].Active)
                return;

            _outEdgeEndpoints[outIndex].Node.DeregisterTail(_outEdgeEndpoints[outIndex].Index);
            DeregisterHead(outIndex);
        }

        /// <summary>
        /// Disconnects from a tail.
        /// </summary>
        /// <param name="inIndex">This node's input index that is connected to the tail.</param>
        public void DisconnectFromTail(Int32 inIndex)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (!_inEdgeEndpoints[inIndex].Active)
                return;

            _inEdgeEndpoints[inIndex].Node.DeregisterHead(_inEdgeEndpoints[inIndex].Index);
            DeregisterTail(inIndex);
        }
        
        /// <summary>
        /// Sets an output node corresponding to the index to the value.
        /// </summary>
        /// <param name="outIndex">The index of the output to set.</param>
        /// <param name="value">The value to set the output to.</param>
        protected void SetOutput(Int32 outIndex, T value)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));

            var outEdge = _outEdgeEndpoints[outIndex];
            if (outEdge.Active)
                outEdge.Node.SetInput(outEdge.Index, value);
        }

        /// <summary>
        /// Updates the outputs based on the input.
        /// </summary>
        protected abstract void InternalUpdate();

        /// <summary>
        /// Registers and activates an output and head.
        /// </summary>
        /// <param name="outIndex">The output index of this node to use.</param>
        /// <param name="headNode">The output node to register.</param>
        /// <param name="headNodeInputIndex">The input index of the output node to register.</param>
        private void RegisterHead(Int32 outIndex, LogicNode<T> headNode, Int32 headNodeInputIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (headNode == null)
                throw new ArgumentNullException(nameof(headNode));
            if (headNodeInputIndex >= headNode.MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (headNodeInputIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (_outEdgeEndpoints[outIndex].Active)
                throw new OutputEdgeAlreadyActiveException("Out index is already active.", outIndex);

            _outNodes[outIndex] = headNode;
            _outEdgeEndpoints[outIndex].Active = true;
            _outEdgeEndpoints[outIndex].Node = headNode;
            _outEdgeEndpoints[outIndex].Index = headNodeInputIndex;
        }

        /// <summary>
        /// Registers and activates an input and tail.
        /// </summary>
        /// <param name="inIndex">The input index of this node to use.</param>
        /// <param name="tailNode">The input node to register.</param>
        /// <param name="tailNodeOutputIndex">The output index of the input node to register.</param>
        private void RegisterTail(Int32 inIndex, LogicNode<T> tailNode, Int32 tailNodeOutputIndex)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (tailNode == null)
                throw new ArgumentNullException(nameof(tailNode));
            if (tailNodeOutputIndex >= tailNode.MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(tailNodeOutputIndex));
            if (tailNodeOutputIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(tailNodeOutputIndex));
            if (_inEdgeEndpoints[inIndex].Active)
                throw new InputEdgeAlreadyActiveException("Input is already active.", inIndex);

            _inEdgeEndpoints[inIndex].Active = true;
            _inEdgeEndpoints[inIndex].Node = tailNode;
            _inEdgeEndpoints[inIndex].Index = tailNodeOutputIndex;
            Inputs[inIndex].Active = true;
            ActiveInputCount++;
        }

        /// <summary>
        /// Deregisters and deactivates an output and head.
        /// </summary>
        /// <param name="outIndex">This node's output index that is connected to the head.</param>
        private void DeregisterHead(Int32 outIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (!_outEdgeEndpoints[outIndex].Active)
                return;

            _outNodes[outIndex] = null;
            _outEdgeEndpoints[outIndex].Active = false;
            _outEdgeEndpoints[outIndex].Node = null;
            _outEdgeEndpoints[outIndex].Index = -1;
        }

        /// <summary>
        /// Deregisters and deactivates an input and tail.
        /// </summary>
        /// <param name="inIndex">This node's input index that is connected to the tail.</param>
        private void DeregisterTail(Int32 inIndex)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (!_inEdgeEndpoints[inIndex].Active)
                return;

            _inEdgeEndpoints[inIndex].Active = false;
            _inEdgeEndpoints[inIndex].Node = null;
            _inEdgeEndpoints[inIndex].Index = -1;
            Inputs[inIndex].Active = false;
            ActiveInputCount--;
        }

        /// <summary>
        /// Sets the input corresponding to the index to the value.
        /// </summary>
        /// <param name="inIndex">The index of the input to set.</param>
        /// <param name="value">The value to set the input to.</param>
        private void SetInput(Int32 inIndex, T value)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (!Inputs[inIndex].Active)
                throw new InvalidOperationException("SetInput cannot be called on an unregistered input.");

            Inputs[inIndex].Set = true;
            Inputs[inIndex].Value = value;
            SettedInputCount++;
        }

        /// <summary>
        /// Resets the inputs to unset.
        /// </summary>
        private void ResetInputs()
        {
            for (Int32 i = 0; i < MaxInputCount; i++)
            {
                Inputs[i].Set = false;
            }

            SettedInputCount = 0;
        }
    }
}
