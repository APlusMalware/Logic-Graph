using System;
using System.Collections.Generic;

namespace APlusMalware.LogicGraph
{
    public abstract class LogicNode<T>
    {
        private List<LogicNode<T>> _outNodes;
        private List<Int32> _outNodeInputIndexes;
        private IList<LogicNode<T>> _readOnlyOutNodes;
        private IList<Int32> _readOnlyOutNodeInputIndexes;
        private IList<LogicNode<T>> _inputNodes;

        public Int32 LastStep { get; private set; } = -1;

        public abstract T[] InputValues { get; }

        public abstract T[] OutputValues { get; }

        public abstract Int32 MaxOutputCount { get; }

        public abstract Int32 MaxInputCount { get; }

        public Int32 ActiveInputCount { get; private set; }

        public Int32 SettedInputCount { get; private set; }

        public Boolean AreAllSet { get { return ActiveInputCount == SettedInputCount; } }

        public Boolean AreSomeSet { get { return ActiveInputCount != 0; } }

        public IList<LogicNode<T>> OutNodes
        {
            get
            {
                if (_outNodes == null)
                {
                    InitOutNodes();
                }
                return _readOnlyOutNodes;
            }
        }

        protected IList<Int32> OutNodeInputIndexes
        {
            get
            {
                if (_outNodes == null)
                {
                    InitOutNodes();
                }
                return _readOnlyOutNodeInputIndexes;
            }
        }


        protected List<LogicInput<T>> Inputs { get; private set; }

        public void Update(Int32 stepNumber)
        {
            LastStep = stepNumber;
            InternalUpdate();
            ResetInputs();
        }

        protected abstract void InternalUpdate();

        public void RegisterOutputNode(Int32 index, LogicNode<T> node, Int32 nodeInputIndex)
        {
            if (index >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(index));
            if (node == null)
                throw new ArgumentNullException(nameof(node));

            if (_outNodes == null)
                InitOutNodes();

            _outNodes[index] = node;
            _outNodeInputIndexes[index] = nodeInputIndex;
            node.RegisterInputNode(nodeInputIndex, this);
        }

        public void DeregisterOutputNode(Int32 index)
        {
            if (index >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(index));

            var n = OutNodes[index];
            if (n == null) return;
            n.DeregisterInputNode(_outNodeInputIndexes[index]);
        }
        
        public void DeregisterAllOutputs()
        {
            for (Int32 i = 0; i < OutNodes.Count; i++)
            {
                DeregisterOutputNode(i);
            }
        }

        public void RegisterInputNode(Int32 index, LogicNode<T> node)
        {
            if (index >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(index));
            if (node == null)
                throw new ArgumentNullException(nameof(node));

            if (Inputs == null)
                InitInputs();

            if (Inputs[index].Active)
                return;
            Inputs[index].Active = true;

            ActiveInputCount++;
        }

        public void DeregisterInputNode(Int32 index)
        {
            if (index >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(index));
            if (Inputs == null)
                return;

            if (!Inputs[index].Active)
                return;
            Inputs[index].Active = false;
            ActiveInputCount--;
        }

        public void DeregisterAll()
        {

        }

        public void SetInput(Int32 index, T value)
        {
            if (index >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(index));
            if (Inputs == null || !Inputs[index].Active)
                throw new InvalidOperationException("SetInput cannot be called on an unregistered input.");

            Inputs[index].Set = true;
            Inputs[index].Value = value;
            SettedInputCount++;
        }

        protected void ResetInputs()
        {
            for (Int32 i = 0; i < MaxInputCount; i++)
            {
                Inputs[i].Set = false;
            }

            SettedInputCount = 0;
        }

        private void InitOutNodes()
        {
            _outNodes = new List<LogicNode<T>>(MaxOutputCount);
            _outNodeInputIndexes = new List<Int32>(MaxOutputCount);
            for (Int32 i = 0; i < MaxOutputCount; i++)
            {
                _outNodeInputIndexes.Add(-1);
                _outNodes.Add(null);
            }
            _readOnlyOutNodes = _outNodes.AsReadOnly();
            _readOnlyOutNodeInputIndexes = _outNodeInputIndexes.AsReadOnly();
        }

        private void InitInputs()
        {
            Inputs = new List<LogicInput<T>>(MaxInputCount);
            for(Int32 i = 0; i < MaxInputCount; i++)
            {
                Inputs.Add(new LogicInput<T>());
            }
        }
    }
}
