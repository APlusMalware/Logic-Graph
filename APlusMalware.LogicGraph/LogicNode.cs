namespace APlusMalware.LogicGraph
{
    using System;
    using System.Collections.Generic;

    public abstract class LogicNode<T>
    {
        private readonly List<LogicNode<T>> _outNodes;

        private readonly EdgeEndpoint<T>[] _inEdgeEndpoints;
        private readonly EdgeEndpoint<T>[] _outEdgeEndpoints;

        protected LogicNode()
        {
            _outNodes = new List<LogicNode<T>>(MaxOutputCount);
            _outEdgeEndpoints = new EdgeEndpoint<T>[MaxOutputCount];

            for (Int32 i = 0; i < MaxOutputCount; i++)
            {
                _outNodes.Add(null);
                _outEdgeEndpoints[i] = new EdgeEndpoint<T>();
            }
            OutNodes = _outNodes.AsReadOnly();

            Inputs = new List<LogicInput<T>>(MaxInputCount);
            _inEdgeEndpoints = new EdgeEndpoint<T>[MaxInputCount];
            for (Int32 i = 0; i < MaxInputCount; i++)
            {
                Inputs.Add(new LogicInput<T>());
                _inEdgeEndpoints[i] = new EdgeEndpoint<T>();
            }
        }

        public Int32 LastStep { get; private set; } = -1;

        public abstract T[] InputValues { get; }

        public abstract T[] OutputValues { get; }

        public abstract Int32 MaxOutputCount { get; }

        public abstract Int32 MaxInputCount { get; }

        public Int32 ActiveInputCount { get; private set; }

        public Int32 SettedInputCount { get; private set; }

        public Boolean AreAllSet { get { return ActiveInputCount == SettedInputCount; } }

        public Boolean AreSomeSet { get { return ActiveInputCount != 0; } }

        public IList<LogicNode<T>> OutNodes { get; }
        
        protected List<LogicInput<T>> Inputs { get; }

        public void Update(Int32 stepNumber)
        {
            LastStep = stepNumber;
            InternalUpdate();
            ResetInputs();
        }

        public void ConnectToHead(Int32 outIndex, LogicNode<T> headNode, Int32 headNodeInputIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (headNode == null)
                throw new ArgumentNullException(nameof(headNode));
            if (headNodeInputIndex >= headNode.MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (headNodeInputIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (_outEdgeEndpoints[outIndex].Active)
                throw new ArgumentException("Output is already active.", nameof(outIndex));
            if (headNode.Inputs[headNodeInputIndex].Active)
                throw new ArgumentException("EdgeEndpoint node input is already active.", nameof(headNodeInputIndex));
            
            headNode.RegisterTail(headNodeInputIndex, this, outIndex);
            RegisterHead(outIndex, headNode, headNodeInputIndex);
        }

        public void DisconnectAll()
        {
            for (Int32 i = 0; i < _outEdgeEndpoints.Length; i++)
            {
                DisconnectFromHead(i);
            }

            for (Int32 i = 0; i < _inEdgeEndpoints.Length; i++)
            {
                DisconnectFromTail(i);
            }
        }

        public void DisconnectFromHead(Int32 outIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (!_outEdgeEndpoints[outIndex].Active)
                return;

            _outEdgeEndpoints[outIndex].Node.DeregisterTail(_outEdgeEndpoints[outIndex].Index);
            DeregisterHead(outIndex);
        }

        public void DisconnectFromTail(Int32 inIndex)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (!_inEdgeEndpoints[inIndex].Active)
                return;

            _inEdgeEndpoints[inIndex].Node.DeregisterHead(_inEdgeEndpoints[inIndex].Index);
            DeregisterTail(inIndex);
        }

        public void RegisterHead(Int32 outIndex, LogicNode<T> headNode, Int32 headNodeInputIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (headNode == null)
                throw new ArgumentNullException(nameof(headNode));
            if (headNodeInputIndex >= headNode.MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (headNodeInputIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(headNodeInputIndex));
            if (_outEdgeEndpoints[outIndex].Active)
                throw new ArgumentException("Out inIndex is already active.", nameof(outIndex));

            _outNodes[outIndex] = headNode;
            _outEdgeEndpoints[outIndex].Active = true;
            _outEdgeEndpoints[outIndex].Node = headNode;
            _outEdgeEndpoints[outIndex].Index = headNodeInputIndex;
        }

        public void RegisterTail(Int32 inIndex, LogicNode<T> tailNode, Int32 tailNodeOutputIndex)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (tailNode == null)
                throw new ArgumentNullException(nameof(tailNode));
            if (tailNodeOutputIndex >= tailNode.MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(tailNodeOutputIndex));
            if (tailNodeOutputIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(tailNodeOutputIndex));
            if (_inEdgeEndpoints[inIndex].Active)
                throw new ArgumentException("Input is already active.", nameof(inIndex));

            _inEdgeEndpoints[inIndex].Active = true;
            _inEdgeEndpoints[inIndex].Node = tailNode;
            _inEdgeEndpoints[inIndex].Index = tailNodeOutputIndex;
            Inputs[inIndex].Active = true;
            ActiveInputCount++;
        }

        public void DeregisterHead(Int32 outIndex)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (!_outEdgeEndpoints[outIndex].Active)
                return;

            _outNodes[outIndex] = null;
            _outEdgeEndpoints[outIndex].Active = false;
            _outEdgeEndpoints[outIndex].Node = null;
            _outEdgeEndpoints[outIndex].Index = -1;
        }

        public void DeregisterTail(Int32 inIndex)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (!_inEdgeEndpoints[inIndex].Active)
                return;

            _inEdgeEndpoints[inIndex].Active = false;
            _inEdgeEndpoints[inIndex].Node = null;
            _inEdgeEndpoints[inIndex].Index = -1;
            Inputs[inIndex].Active = false;
            ActiveInputCount--;
        }

        public void SetInput(Int32 inIndex, T value)
        {
            if (inIndex >= MaxInputCount)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (inIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(inIndex));
            if (!Inputs[inIndex].Active)
                throw new InvalidOperationException("SetInput cannot be called on an unregistered input.");

            Inputs[inIndex].Set = true;
            Inputs[inIndex].Value = value;
            SettedInputCount++;
        }

        public void SetOutput(Int32 outIndex, T value)
        {
            if (outIndex >= MaxOutputCount)
                throw new ArgumentOutOfRangeException(nameof(outIndex));
            if (outIndex < 0)
                throw new ArgumentOutOfRangeException(nameof(outIndex));

            var outEdge = _outEdgeEndpoints[outIndex];
            if (outEdge.Active)
                outEdge.Node.SetInput(outEdge.Index, value);
        }

        protected abstract void InternalUpdate();

        protected void ResetInputs()
        {
            for (Int32 i = 0; i < MaxInputCount; i++)
            {
                Inputs[i].Set = false;
            }

            SettedInputCount = 0;
        }
    }
}
